"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_LDRViewer_tsx",{

/***/ "(pages-dir-browser)/./components/LDRViewer.tsx":
/*!**********************************!*\
  !*** ./components/LDRViewer.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(pages-dir-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var three_examples_jsm_loaders_LDrawLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/loaders/LDrawLoader.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/loaders/LDrawLoader.js\");\n/* harmony import */ var three_examples_jsm_materials_LDrawConditionalLineMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/materials/LDrawConditionalLineMaterial.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst LDRViewerComponent = (param)=>{\n    let { modelPath, ldrawContent } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sceneRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rendererRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const modelGroupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const loadingManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isLoadingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const currentModelPathRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('');\n    const isInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const errorCountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Create loading manager only once\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (loadingManagerRef.current) return;\n            const manager = new three__WEBPACK_IMPORTED_MODULE_2__.LoadingManager();\n            // Implement path resolution strategy similar to Three.js packLDrawModel\n            manager.setURLModifier({\n                \"LDRViewerComponent.useEffect\": (url)=>{\n                    // console.log('Original URL:', url);\n                    // Normalize path separators\n                    let normalized = url.replace(/\\\\/g, '/');\n                    // Handle s\\ prefix for subparts (convert s\\file.dat to s/file.dat)\n                    if (normalized.includes('s/') || normalized.match(/s[\\\\\\/]/)) {\n                        const parts = normalized.split(/[\\\\\\/]/);\n                        const lastTwo = parts.slice(-2);\n                        if (lastTwo[0] === 's') {\n                            // This is a subpart reference\n                            normalized = \"/ldraw/parts/s/\".concat(lastTwo[1]);\n                            // console.log('Subpart detected, normalized to:', normalized);\n                            return normalized;\n                        }\n                    }\n                    // Extract the filename and check for subdirectory (like s/)\n                    const urlParts = normalized.split('/');\n                    const filename = urlParts[urlParts.length - 1].toLowerCase();\n                    const hasSubdir = urlParts.length >= 2 && urlParts[urlParts.length - 2] === 's';\n                    // Define possible path prefixes to try\n                    const pathPrefixes = [\n                        '/output/',\n                        '/ldraw/',\n                        '/ldraw/p/',\n                        '/ldraw/parts/'\n                    ];\n                    // If the URL already has a valid prefix, clean it up\n                    for (const prefix of pathPrefixes){\n                        if (normalized.includes(prefix)) {\n                            // Clean up any duplicate path segments\n                            normalized = normalized.replace(/\\/ldraw\\/parts\\/parts\\//g, '/ldraw/parts/');\n                            normalized = normalized.replace(/\\/ldraw\\/p\\/p\\//g, '/ldraw/p/');\n                            normalized = normalized.replace(/\\/output\\/output\\//g, '/output/');\n                            // Remove any redundant path combinations but preserve s/ subdirectory\n                            if (!normalized.includes('/s/')) {\n                                normalized = normalized.replace(/\\/ldraw\\/parts\\/p\\//g, '/ldraw/p/');\n                                normalized = normalized.replace(/\\/output\\/p\\//g, '/ldraw/p/');\n                                normalized = normalized.replace(/\\/ldraw\\/p\\/parts\\//g, '/ldraw/parts/');\n                                normalized = normalized.replace(/\\/output\\/parts\\//g, '/ldraw/parts/');\n                            } else {\n                                // Handle subparts in s/ directory\n                                normalized = normalized.replace(/\\/ldraw\\/parts\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                                normalized = normalized.replace(/\\/ldraw\\/p\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                                normalized = normalized.replace(/\\/output\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                            }\n                            // console.log('Normalized URL:', normalized);\n                            return normalized;\n                        }\n                    }\n                    // If no valid prefix found, try to construct the path\n                    // This handles cases where the URL is just a filename or relative path\n                    if (!normalized.startsWith('/ldraw/')) {\n                        // Handle subparts (files in s/ directory)\n                        if (hasSubdir) {\n                            normalized = \"/ldraw/parts/s/\".concat(filename);\n                        } else if (filename.match(/^\\d/) || filename.startsWith('stud') || filename.startsWith('edge')) {\n                            normalized = \"/ldraw/p/\".concat(filename);\n                        } else if (filename.endsWith('.dat')) {\n                            normalized = \"/ldraw/parts/\".concat(filename);\n                        } else if (filename.endsWith('.ldr') || filename.endsWith('.mpd')) {\n                            normalized = \"/output/\".concat(filename);\n                        }\n                    // console.log('Constructed URL:', normalized);\n                    }\n                    return normalized;\n                }\n            }[\"LDRViewerComponent.useEffect\"]);\n            loadingManagerRef.current = manager;\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    manager.setURLModifier(undefined);\n                    loadingManagerRef.current = null;\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (!containerRef.current || isInitializedRef.current) return;\n            isInitializedRef.current = true;\n            const container = containerRef.current;\n            const width = container.clientWidth;\n            const height = container.clientHeight;\n            const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n            scene.background = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xeeeeee);\n            sceneRef.current = scene;\n            // Camera with settings optimized for large LEGO models\n            const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(45, width / height, 0.1, 50000);\n            camera.position.set(300, 400, 700);\n            cameraRef.current = camera;\n            const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n                antialias: true\n            });\n            renderer.setSize(width, height);\n            renderer.setPixelRatio(window.devicePixelRatio);\n            container.appendChild(renderer.domElement);\n            rendererRef.current = renderer;\n            const controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            controls.enablePan = true;\n            controls.enableRotate = true;\n            controls.enableZoom = true;\n            controls.screenSpacePanning = false;\n            controls.minDistance = 10;\n            controls.maxDistance = 2000;\n            controls.target.set(0, 0, 0);\n            controlsRef.current = controls;\n            // Enhanced lighting for better visibility\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_2__.AmbientLight(0xffffff, 0.9)); // Brighter ambient light\n            // Main directional light\n            const dirLight = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 1.0);\n            dirLight.position.set(500, 1000, 500);\n            dirLight.castShadow = false;\n            scene.add(dirLight);\n            // Additional fill lights from different angles\n            const fillLight1 = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 0.5);\n            fillLight1.position.set(-500, 500, -500);\n            scene.add(fillLight1);\n            const fillLight2 = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 0.5);\n            fillLight2.position.set(500, 500, -500);\n            scene.add(fillLight2);\n            // Add a hemisphere light for more natural lighting\n            const hemiLight = new three__WEBPACK_IMPORTED_MODULE_2__.HemisphereLight(0xffffff, 0xcccccc, 0.4);\n            hemiLight.position.set(0, 500, 0);\n            scene.add(hemiLight);\n            // Grid helper removed\n            // const gridHelper = new THREE.GridHelper(1000, 20);\n            // scene.add(gridHelper);\n            // Add axes helper\n            const axesHelper = new three__WEBPACK_IMPORTED_MODULE_2__.AxesHelper(500);\n            scene.add(axesHelper);\n            const handleResize = {\n                \"LDRViewerComponent.useEffect.handleResize\": ()=>{\n                    if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;\n                    const w = containerRef.current.clientWidth;\n                    const h = containerRef.current.clientHeight;\n                    rendererRef.current.setSize(w, h);\n                    cameraRef.current.aspect = w / h;\n                    cameraRef.current.updateProjectionMatrix();\n                }\n            }[\"LDRViewerComponent.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            // Animation loop is now handled in the cube effect\n            console.log('Scene initialized');\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                // Keep renderer intact but clean up event listener\n                // if (rendererRef.current && containerRef.current) {\n                //   containerRef.current.removeChild(rendererRef.current.domElement);\n                //   rendererRef.current.dispose();\n                // }\n                // isInitializedRef.current = false;\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    // Animation loop - using useRef to ensure single instance\n    const animationIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isAnimatingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !controlsRef.current) return;\n            // Prevent multiple animation loops\n            if (isAnimatingRef.current) {\n                console.log('Animation already running, skipping...');\n                return;\n            }\n            // Commented out cancellation\n            // if (animationIdRef.current !== null) {\n            //   cancelAnimationFrame(animationIdRef.current);\n            // }\n            isAnimatingRef.current = true;\n            const animate = {\n                \"LDRViewerComponent.useEffect.animate\": ()=>{\n                    if (!isAnimatingRef.current) return;\n                    // Check all refs before scheduling next frame\n                    if (!controlsRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) {\n                        console.warn('Animation loop stopped: missing refs');\n                        isAnimatingRef.current = false;\n                        return;\n                    }\n                    animationIdRef.current = requestAnimationFrame(animate);\n                    try {\n                        // Only validate scene if we've had recent errors\n                        if (errorCountRef.current > 0 && errorCountRef.current < 5) {\n                            let hasNullChildren = false;\n                            let nullCheckCount = 0;\n                            sceneRef.current.traverse({\n                                \"LDRViewerComponent.useEffect.animate\": (child)=>{\n                                    nullCheckCount++;\n                                    // Check if the object itself has required properties\n                                    if (!child.hasOwnProperty('visible')) {\n                                        console.error('Object missing visible property:', child);\n                                    }\n                                    if (child.children) {\n                                        for(let i = 0; i < child.children.length; i++){\n                                            if (child.children[i] === null || child.children[i] === undefined) {\n                                                console.error('Found null/undefined child in scene at index', i, 'of parent:', child);\n                                                hasNullChildren = true;\n                                                // Remove the null child\n                                                child.children.splice(i, 1);\n                                                i--; // Adjust index after removal\n                                            }\n                                        }\n                                    }\n                                }\n                            }[\"LDRViewerComponent.useEffect.animate\"]);\n                            if (hasNullChildren) {\n                                console.warn('Cleaned null children from scene graph after checking', nullCheckCount, 'objects');\n                            }\n                        }\n                        // Update controls and render\n                        // Validate controls state before updating\n                        if (controlsRef.current) {\n                            // Check if controls target is valid\n                            if (!isFinite(controlsRef.current.target.x) || !isFinite(controlsRef.current.target.y) || !isFinite(controlsRef.current.target.z)) {\n                                console.warn('OrbitControls target became invalid, resetting to origin');\n                                controlsRef.current.target.set(0, 0, 0);\n                            }\n                            controlsRef.current.update();\n                        }\n                        rendererRef.current.render(sceneRef.current, cameraRef.current);\n                        // Reset error counter on successful render\n                        if (errorCountRef.current > 0) {\n                            console.log('Rendering recovered after', errorCountRef.current, 'errors');\n                            errorCountRef.current = 0;\n                        }\n                    } catch (error) {\n                        errorCountRef.current = (errorCountRef.current || 0) + 1;\n                        if (errorCountRef.current === 1) {\n                            // Only log detailed info on first error\n                            console.error('First error in animation loop:', error);\n                            console.error('Scene children count:', sceneRef.current.children.length);\n                            console.error('Scene state:', sceneRef.current);\n                            console.error('Camera state:', cameraRef.current);\n                            console.error('Controls state:', controlsRef.current);\n                            // Log the model group state\n                            if (modelGroupRef.current) {\n                                console.error('Model group state:', modelGroupRef.current);\n                                console.error('Model visible:', modelGroupRef.current.visible);\n                                console.error('Model children count:', modelGroupRef.current.children.length);\n                            }\n                        }\n                        // Stop animation after too many errors\n                        if (errorCountRef.current > 100) {\n                            console.error('Too many render errors, stopping animation loop');\n                            isAnimatingRef.current = false;\n                        }\n                    }\n                }\n            }[\"LDRViewerComponent.useEffect.animate\"];\n            // Start the animation loop\n            animate();\n            console.log('Animation loop started');\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    // Properly clean up animation loop\n                    isAnimatingRef.current = false;\n                    if (animationIdRef.current !== null) {\n                        cancelAnimationFrame(animationIdRef.current);\n                        animationIdRef.current = null;\n                    }\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    // Test cube commented out - LEGO model should load instead\n    /*\r\n  const cubeRef = useRef<THREE.Mesh | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Prevent adding cube multiple times\r\n    if (cubeRef.current) return;\r\n\r\n    // Add a simple red cube that we know works\r\n    const geometry = new THREE.BoxGeometry(30, 30, 30);\r\n    const material = new THREE.MeshPhongMaterial({\r\n      color: 0xff0000,\r\n      side: THREE.DoubleSide\r\n    });\r\n    const cube = new THREE.Mesh(geometry, material);\r\n    cube.position.set(0, 300, 0);\r\n\r\n    sceneRef.current.add(cube);\r\n\r\n    cubeRef.current = cube;\r\n    console.log('Simple test cube added at:', cube.position);\r\n    console.log('Scene now has', sceneRef.current.children.length, 'children');\r\n\r\n    return () => {\r\n      // Commented out cleanup to keep the cube visible\r\n      // if (sceneRef.current && cube) {\r\n      //   sceneRef.current.remove(cube);  // Also need to prevent removal from scene\r\n      //   geometry.dispose();\r\n      //   material.dispose();\r\n      // }\r\n      // cubeRef.current = null;\r\n    };\r\n  }, []);\r\n  */ // Cube animation commented out since cube is removed\n    /*\r\n  useEffect(() => {\r\n    const animate = () => {\r\n      if (cubeRef.current) {\r\n        cubeRef.current.rotation.x += 0.01;\r\n        cubeRef.current.rotation.y += 0.01;\r\n      }\r\n    };\r\n\r\n    const id = setInterval(animate, 16); // ~60fps\r\n\r\n    // Commented out interval cleanup\r\n    // return () => clearInterval(id);\r\n    return () => {};\r\n  }, []);\r\n  */ // LEGO LOADING CODE\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            // Need either modelPath or ldrawContent\n            if (!modelPath && !ldrawContent || !sceneRef.current || !rendererRef.current || !cameraRef.current) return;\n            // Skip if we're already loading this exact model\n            if (currentModelPathRef.current === modelPath && isLoadingRef.current) {\n                console.log('Same model already loading, skipping...');\n                return;\n            }\n            // Skip if this model is already loaded\n            if (currentModelPathRef.current === modelPath && modelGroupRef.current) {\n                console.log('Model already loaded, skipping...');\n                return;\n            }\n            // Prevent concurrent loads\n            if (isLoadingRef.current) {\n                console.log('Another model is loading, skipping...');\n                return;\n            }\n            // Clean up previous model safely\n            if (modelGroupRef.current && sceneRef.current) {\n                console.log('Removing previous model from scene');\n                // Mark as invisible first to prevent render issues\n                modelGroupRef.current.visible = false;\n                // Remove from scene on next tick\n                const modelToRemove = modelGroupRef.current;\n                modelGroupRef.current = null;\n                setTimeout({\n                    \"LDRViewerComponent.useEffect\": ()=>{\n                        if (sceneRef.current && modelToRemove) {\n                            console.log('Actually removing model and disposing resources');\n                            sceneRef.current.remove(modelToRemove);\n                            // Dispose of geometries and materials if needed\n                            modelToRemove.traverse({\n                                \"LDRViewerComponent.useEffect\": (child)=>{\n                                    if (child.geometry) child.geometry.dispose();\n                                    if (child.material) {\n                                        if (Array.isArray(child.material)) {\n                                            child.material.forEach({\n                                                \"LDRViewerComponent.useEffect\": (mat)=>mat.dispose()\n                                            }[\"LDRViewerComponent.useEffect\"]);\n                                        } else {\n                                            child.material.dispose();\n                                        }\n                                    }\n                                }\n                            }[\"LDRViewerComponent.useEffect\"]);\n                            console.log('Model removal complete');\n                        }\n                    }\n                }[\"LDRViewerComponent.useEffect\"], 0);\n            }\n            // Prevent multiple loads of the same model\n            let cancelled = false;\n            isLoadingRef.current = true;\n            currentModelPathRef.current = modelPath || 'generated';\n            var _loadingManagerRef_current;\n            const loader = new three_examples_jsm_loaders_LDrawLoader_js__WEBPACK_IMPORTED_MODULE_4__.LDrawLoader((_loadingManagerRef_current = loadingManagerRef.current) !== null && _loadingManagerRef_current !== void 0 ? _loadingManagerRef_current : undefined);\n            // Set the parts library path to the ldraw directory\n            loader.setPartsLibraryPath('/ldraw/');\n            // Set the file map for better part resolution\n            loader.setFileMap({});\n            // Set the conditional line material class (not an instance)\n            loader.setConditionalLineMaterial(three_examples_jsm_materials_LDrawConditionalLineMaterial_js__WEBPACK_IMPORTED_MODULE_5__.LDrawConditionalLineMaterial);\n            console.log(ldrawContent ? 'Loading LDraw from content' : \"Loading LDR file: \".concat(modelPath));\n            // Try to preload materials first, but don't fail if it doesn't work\n            const materialsPromise = loader.preloadMaterials('/ldraw/LDConfig.ldr').then({\n                \"LDRViewerComponent.useEffect.materialsPromise\": ()=>{\n                    console.log('Materials preloaded successfully');\n                }\n            }[\"LDRViewerComponent.useEffect.materialsPromise\"]).catch({\n                \"LDRViewerComponent.useEffect.materialsPromise\": (err)=>{\n                    console.warn('Could not preload materials, using defaults:', err.message);\n                }\n            }[\"LDRViewerComponent.useEffect.materialsPromise\"]);\n            // Load the model (wait for materials if possible, but don't block)\n            Promise.all([\n                materialsPromise\n            ]).then({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    if (cancelled) return;\n                    // If we have direct content, parse it; otherwise load from file\n                    if (ldrawContent) {\n                        return loader.parse(ldrawContent, '/');\n                    } else if (modelPath) {\n                        return loader.loadAsync(modelPath);\n                    }\n                    return null;\n                }\n            }[\"LDRViewerComponent.useEffect\"]).then({\n                \"LDRViewerComponent.useEffect\": (group)=>{\n                    var _sceneRef_current;\n                    if (!group || cancelled) return;\n                    console.log('Model loaded successfully:', group);\n                    isLoadingRef.current = false;\n                    // Fix null materials and children issues\n                    group.traverse({\n                        \"LDRViewerComponent.useEffect\": (child)=>{\n                            // Check for null children\n                            if (child.children) {\n                                const originalLength = child.children.length;\n                                child.children = child.children.filter({\n                                    \"LDRViewerComponent.useEffect\": (c)=>c !== null && c !== undefined\n                                }[\"LDRViewerComponent.useEffect\"]);\n                                if (child.children.length !== originalLength) {\n                                    console.warn('Removed null children from:', child.name || child.uuid);\n                                }\n                            }\n                            // Fix null materials\n                            if (child.isMesh) {\n                                const mesh = child;\n                                if (!mesh.material) {\n                                    // Create a default material if missing\n                                    mesh.material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                        color: 0x808080,\n                                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                    });\n                                    console.log('Added default material to mesh:', mesh.name);\n                                } else if (Array.isArray(mesh.material)) {\n                                    // Check array of materials\n                                    mesh.material = mesh.material.map({\n                                        \"LDRViewerComponent.useEffect\": (mat)=>{\n                                            if (!mat) {\n                                                console.log('Replacing null material in array');\n                                                return new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                                    color: 0x808080,\n                                                    side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                                });\n                                            }\n                                            return mat;\n                                        }\n                                    }[\"LDRViewerComponent.useEffect\"]);\n                                }\n                            }\n                        }\n                    }[\"LDRViewerComponent.useEffect\"]);\n                    // Position model at origin and rotate 180 degrees\n                    group.position.set(0, 0, 0);\n                    // group.rotation.x = Math.PI; // Rotate 180 degrees around X axis\n                    modelGroupRef.current = group;\n                    if (sceneRef.current) {\n                        sceneRef.current.add(group);\n                        console.log('Model added to scene');\n                        console.log('Group children:', group.children.length);\n                        console.log('Group visible:', group.visible);\n                        console.log('Group in scene:', sceneRef.current.children.includes(group));\n                        // Make sure the group is visible\n                        group.visible = true;\n                        group.traverse({\n                            \"LDRViewerComponent.useEffect\": (child)=>{\n                                child.visible = true;\n                            }\n                        }[\"LDRViewerComponent.useEffect\"]);\n                        // Count visible meshes and check materials\n                        let meshCount = 0;\n                        let visibleCount = 0;\n                        group.traverse({\n                            \"LDRViewerComponent.useEffect\": (child)=>{\n                                if (child.isMesh) {\n                                    var _mesh_geometry_attributes_position;\n                                    meshCount++;\n                                    const mesh = child;\n                                    if (mesh.visible) visibleCount++;\n                                    if (!mesh.geometry.boundingBox) {\n                                        mesh.geometry.computeBoundingBox();\n                                    }\n                                    // Log mesh details\n                                    console.log('Mesh details:', {\n                                        name: mesh.name,\n                                        visible: mesh.visible,\n                                        material: mesh.material,\n                                        geometryVertices: ((_mesh_geometry_attributes_position = mesh.geometry.attributes.position) === null || _mesh_geometry_attributes_position === void 0 ? void 0 : _mesh_geometry_attributes_position.count) || 0,\n                                        position: mesh.position,\n                                        scale: mesh.scale\n                                    });\n                                    // Make sure mesh has a material\n                                    if (!mesh.material) {\n                                        console.warn('Mesh has no material, adding default');\n                                        mesh.material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                            color: 0xff0000,\n                                            side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                        });\n                                    }\n                                }\n                            }\n                        }[\"LDRViewerComponent.useEffect\"]);\n                        console.log(\"Found \".concat(meshCount, \" meshes, \").concat(visibleCount, \" visible\"));\n                    // Test cube removed - rendering verified to be working\n                    // const testGeometry = new THREE.BoxGeometry(50, 50, 50);\n                    // const testMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });\n                    // const testCube = new THREE.Mesh(testGeometry, testMaterial);\n                    // testCube.position.set(100, 25, 0);\n                    // sceneRef.current.add(testCube);\n                    // console.log('Test cube added at:', testCube.position);\n                    }\n                    // Force update matrices before calculating bounding box\n                    group.updateMatrixWorld(true);\n                    // Calculate bounding box and center camera\n                    const box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(group);\n                    const center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n                    const size = box.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n                    // Log model information\n                    if (!box.isEmpty() && size.x > 0 && size.y > 0 && size.z > 0) {\n                        console.log('Model center:', center.x, center.y, center.z);\n                        console.log('Model size:', size.x, size.y, size.z);\n                    } else {\n                        console.warn('Model has empty/invalid bounding box');\n                    }\n                    if (controlsRef.current) {\n                        // Just update controls to look at origin\n                        controlsRef.current.target.set(0, 0, 0);\n                        controlsRef.current.update();\n                    }\n                    // The animation loop will handle rendering\n                    console.log('Scene children:', ((_sceneRef_current = sceneRef.current) === null || _sceneRef_current === void 0 ? void 0 : _sceneRef_current.children.length) || 0);\n                }\n            }[\"LDRViewerComponent.useEffect\"]).catch({\n                \"LDRViewerComponent.useEffect\": (error)=>{\n                    if (cancelled) return;\n                    console.error('Error loading model:', error);\n                    console.error('Model path:', modelPath);\n                    console.error('Stack trace:', error.stack);\n                    isLoadingRef.current = false;\n                }\n            }[\"LDRViewerComponent.useEffect\"]);\n            // Cleanup function - only remove model if path changes or component unmounts\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    cancelled = true;\n                // Don't clear the model here - it will be cleared when a new model loads\n                // or when the component unmounts\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], [\n        modelPath\n    ]);\n    // Clean up model when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    if (modelGroupRef.current && sceneRef.current) {\n                        // Mark as invisible first\n                        modelGroupRef.current.visible = false;\n                        // Then remove\n                        sceneRef.current.remove(modelGroupRef.current);\n                        modelGroupRef.current = null;\n                    }\n                    isLoadingRef.current = false;\n                    currentModelPathRef.current = '';\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: '100%',\n            height: '600px',\n            border: '1px solid #ccc',\n            borderRadius: '8px',\n            overflow: 'hidden'\n        }\n    }, void 0, false, {\n        fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n        lineNumber: 647,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LDRViewerComponent, \"N5qHrZzuFXqi/iZqzj98dLJNCAc=\");\n_c = LDRViewerComponent;\nconst LDRViewer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(LDRViewerComponent);\n_c1 = LDRViewer;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LDRViewer);\nvar _c, _c1;\n$RefreshReg$(_c, \"LDRViewerComponent\");\n$RefreshReg$(_c1, \"LDRViewer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvTERSVmlld2VyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUN4QjtBQUM4QztBQUNMO0FBQ29DO0FBTzVHLE1BQU1RLHFCQUErQztRQUFDLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFOztJQUMvRSxNQUFNQyxlQUFlVCw2Q0FBTUEsQ0FBaUI7SUFDNUMsTUFBTVUsV0FBV1YsNkNBQU1BLENBQXFCO0lBQzVDLE1BQU1XLGNBQWNYLDZDQUFNQSxDQUE2QjtJQUN2RCxNQUFNWSxZQUFZWiw2Q0FBTUEsQ0FBaUM7SUFDekQsTUFBTWEsY0FBY2IsNkNBQU1BLENBQXVCO0lBQ2pELE1BQU1jLGdCQUFnQmQsNkNBQU1BLENBQXFCO0lBQ2pELE1BQU1lLG9CQUFvQmYsNkNBQU1BLENBQThCO0lBQzlELE1BQU1nQixlQUFlaEIsNkNBQU1BLENBQVU7SUFDckMsTUFBTWlCLHNCQUFzQmpCLDZDQUFNQSxDQUFTO0lBQzNDLE1BQU1rQixtQkFBbUJsQiw2Q0FBTUEsQ0FBVTtJQUN6QyxNQUFNbUIsZ0JBQWdCbkIsNkNBQU1BLENBQVM7SUFFckMsbUNBQW1DO0lBQ25DRCxnREFBU0E7d0NBQUM7WUFDUixJQUFJZ0Isa0JBQWtCSyxPQUFPLEVBQUU7WUFFL0IsTUFBTUMsVUFBVSxJQUFJbkIsaURBQW9CO1lBRXhDLHdFQUF3RTtZQUN4RW1CLFFBQVFFLGNBQWM7Z0RBQUMsQ0FBQ0M7b0JBQ3RCLHFDQUFxQztvQkFFckMsNEJBQTRCO29CQUM1QixJQUFJQyxhQUFhRCxJQUFJRSxPQUFPLENBQUMsT0FBTztvQkFFcEMsbUVBQW1FO29CQUNuRSxJQUFJRCxXQUFXRSxRQUFRLENBQUMsU0FBU0YsV0FBV0csS0FBSyxDQUFDLFlBQVk7d0JBQzVELE1BQU1DLFFBQVFKLFdBQVdLLEtBQUssQ0FBQzt3QkFDL0IsTUFBTUMsVUFBVUYsTUFBTUcsS0FBSyxDQUFDLENBQUM7d0JBQzdCLElBQUlELE9BQU8s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QSxNQUFNb0UsS0FBSztvQkFDekM3SixhQUFhSSxPQUFPLEdBQUc7Z0JBQ3pCOztZQUVGLDZFQUE2RTtZQUM3RTtnREFBTztvQkFDTDJHLFlBQVk7Z0JBQ1oseUVBQXlFO2dCQUN6RSxpQ0FBaUM7Z0JBQ25DOztRQUNGO3VDQUFHO1FBQUN4SDtLQUFVO0lBRWQseUNBQXlDO0lBQ3pDUixnREFBU0E7d0NBQUM7WUFDUjtnREFBTztvQkFDTCxJQUFJZSxjQUFjTSxPQUFPLElBQUlWLFNBQVNVLE9BQU8sRUFBRTt3QkFDN0MsMEJBQTBCO3dCQUMxQk4sY0FBY00sT0FBTyxDQUFDK0YsT0FBTyxHQUFHO3dCQUNoQyxjQUFjO3dCQUNkekcsU0FBU1UsT0FBTyxDQUFDbUcsTUFBTSxDQUFDekcsY0FBY00sT0FBTzt3QkFDN0NOLGNBQWNNLE9BQU8sR0FBRztvQkFDMUI7b0JBQ0FKLGFBQWFJLE9BQU8sR0FBRztvQkFDdkJILG9CQUFvQkcsT0FBTyxHQUFHO2dCQUNoQzs7UUFDRjt1Q0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUMwSjtRQUNDQyxLQUFLdEs7UUFDTHVLLE9BQU87WUFDTHBJLE9BQU87WUFDUEUsUUFBUTtZQUNSbUksUUFBUTtZQUNSQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjs7Ozs7O0FBR047R0F0b0JNN0s7S0FBQUE7QUF3b0JOLE1BQU04SywwQkFBWW5MLDJDQUFJQSxDQUFDSzs7QUFDdkIsaUVBQWU4SyxTQUFTQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZ25vbWUvbGVnby9icmlja3lhcmQvY29tcG9uZW50cy9MRFJWaWV3ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgbWVtbyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xyXG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMnO1xyXG5pbXBvcnQgeyBMRHJhd0xvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0xEcmF3TG9hZGVyLmpzJztcclxuaW1wb3J0IHsgTERyYXdDb25kaXRpb25hbExpbmVNYXRlcmlhbCB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9tYXRlcmlhbHMvTERyYXdDb25kaXRpb25hbExpbmVNYXRlcmlhbC5qcyc7XHJcblxyXG5pbnRlcmZhY2UgTERSVmlld2VyUHJvcHMge1xyXG4gIG1vZGVsUGF0aD86IHN0cmluZztcclxuICBsZHJhd0NvbnRlbnQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IExEUlZpZXdlckNvbXBvbmVudDogUmVhY3QuRkM8TERSVmlld2VyUHJvcHM+ID0gKHsgbW9kZWxQYXRoLCBsZHJhd0NvbnRlbnQgfSkgPT4ge1xyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3Qgc2NlbmVSZWYgPSB1c2VSZWY8VEhSRUUuU2NlbmUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCByZW5kZXJlclJlZiA9IHVzZVJlZjxUSFJFRS5XZWJHTFJlbmRlcmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY2FtZXJhUmVmID0gdXNlUmVmPFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY29udHJvbHNSZWYgPSB1c2VSZWY8T3JiaXRDb250cm9scyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IG1vZGVsR3JvdXBSZWYgPSB1c2VSZWY8VEhSRUUuR3JvdXAgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBsb2FkaW5nTWFuYWdlclJlZiA9IHVzZVJlZjxUSFJFRS5Mb2FkaW5nTWFuYWdlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGlzTG9hZGluZ1JlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgY3VycmVudE1vZGVsUGF0aFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcclxuICBjb25zdCBpc0luaXRpYWxpemVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBlcnJvckNvdW50UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIENyZWF0ZSBsb2FkaW5nIG1hbmFnZXIgb25seSBvbmNlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChsb2FkaW5nTWFuYWdlclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xyXG5cclxuICAgIC8vIEltcGxlbWVudCBwYXRoIHJlc29sdXRpb24gc3RyYXRlZ3kgc2ltaWxhciB0byBUaHJlZS5qcyBwYWNrTERyYXdNb2RlbFxyXG4gICAgbWFuYWdlci5zZXRVUkxNb2RpZmllcigodXJsKSA9PiB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdPcmlnaW5hbCBVUkw6JywgdXJsKTtcclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIHNlcGFyYXRvcnNcclxuICAgICAgbGV0IG5vcm1hbGl6ZWQgPSB1cmwucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG5cclxuICAgICAgLy8gSGFuZGxlIHNcXCBwcmVmaXggZm9yIHN1YnBhcnRzIChjb252ZXJ0IHNcXGZpbGUuZGF0IHRvIHMvZmlsZS5kYXQpXHJcbiAgICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCdzLycpIHx8IG5vcm1hbGl6ZWQubWF0Y2goL3NbXFxcXFxcL10vKSkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gbm9ybWFsaXplZC5zcGxpdCgvW1xcXFxcXC9dLyk7XHJcbiAgICAgICAgY29uc3QgbGFzdFR3byA9IHBhcnRzLnNsaWNlKC0yKTtcclxuICAgICAgICBpZiAobGFzdFR3b1swXSA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgc3VicGFydCByZWZlcmVuY2VcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBgL2xkcmF3L3BhcnRzL3MvJHtsYXN0VHdvWzFdfWA7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3VicGFydCBkZXRlY3RlZCwgbm9ybWFsaXplZCB0bzonLCBub3JtYWxpemVkKTtcclxuICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCB0aGUgZmlsZW5hbWUgYW5kIGNoZWNrIGZvciBzdWJkaXJlY3RvcnkgKGxpa2Ugcy8pXHJcbiAgICAgIGNvbnN0IHVybFBhcnRzID0gbm9ybWFsaXplZC5zcGxpdCgnLycpO1xyXG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHVybFBhcnRzW3VybFBhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGhhc1N1YmRpciA9IHVybFBhcnRzLmxlbmd0aCA+PSAyICYmIHVybFBhcnRzW3VybFBhcnRzLmxlbmd0aCAtIDJdID09PSAncyc7XHJcblxyXG4gICAgICAvLyBEZWZpbmUgcG9zc2libGUgcGF0aCBwcmVmaXhlcyB0byB0cnlcclxuICAgICAgY29uc3QgcGF0aFByZWZpeGVzID0gW1xyXG4gICAgICAgICcvb3V0cHV0LycsICAgICAgICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIGdlbmVyYXRlZCBtb2RlbHNcclxuICAgICAgICAnL2xkcmF3LycsICAgICAgICAgICAvLyBEaXJlY3QgcGF0aFxyXG4gICAgICAgICcvbGRyYXcvcC8nLCAgICAgICAgIC8vIFByaW1pdGl2ZXNcclxuICAgICAgICAnL2xkcmF3L3BhcnRzLycsICAgICAvLyBQYXJ0c1xyXG4gICAgICBdO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIFVSTCBhbHJlYWR5IGhhcyBhIHZhbGlkIHByZWZpeCwgY2xlYW4gaXQgdXBcclxuICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgcGF0aFByZWZpeGVzKSB7XHJcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQuaW5jbHVkZXMocHJlZml4KSkge1xyXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgYW55IGR1cGxpY2F0ZSBwYXRoIHNlZ21lbnRzXHJcbiAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9sZHJhd1xcL3BhcnRzXFwvcGFydHNcXC8vZywgJy9sZHJhdy9wYXJ0cy8nKTtcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcL2xkcmF3XFwvcFxcL3BcXC8vZywgJy9sZHJhdy9wLycpO1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvb3V0cHV0XFwvb3V0cHV0XFwvL2csICcvb3V0cHV0LycpO1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVkdW5kYW50IHBhdGggY29tYmluYXRpb25zIGJ1dCBwcmVzZXJ2ZSBzLyBzdWJkaXJlY3RvcnlcclxuICAgICAgICAgIGlmICghbm9ybWFsaXplZC5pbmNsdWRlcygnL3MvJykpIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvbGRyYXdcXC9wYXJ0c1xcL3BcXC8vZywgJy9sZHJhdy9wLycpO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9vdXRwdXRcXC9wXFwvL2csICcvbGRyYXcvcC8nKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvbGRyYXdcXC9wXFwvcGFydHNcXC8vZywgJy9sZHJhdy9wYXJ0cy8nKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvb3V0cHV0XFwvcGFydHNcXC8vZywgJy9sZHJhdy9wYXJ0cy8nKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzdWJwYXJ0cyBpbiBzLyBkaXJlY3RvcnlcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvbGRyYXdcXC9wYXJ0c1xcL3BhcnRzXFwvc1xcLy9nLCAnL2xkcmF3L3BhcnRzL3MvJyk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcL2xkcmF3XFwvcFxcL3BhcnRzXFwvc1xcLy9nLCAnL2xkcmF3L3BhcnRzL3MvJyk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcL291dHB1dFxcL3BhcnRzXFwvc1xcLy9nLCAnL2xkcmF3L3BhcnRzL3MvJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ05vcm1hbGl6ZWQgVVJMOicsIG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBubyB2YWxpZCBwcmVmaXggZm91bmQsIHRyeSB0byBjb25zdHJ1Y3QgdGhlIHBhdGhcclxuICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBVUkwgaXMganVzdCBhIGZpbGVuYW1lIG9yIHJlbGF0aXZlIHBhdGhcclxuICAgICAgaWYgKCFub3JtYWxpemVkLnN0YXJ0c1dpdGgoJy9sZHJhdy8nKSkge1xyXG4gICAgICAgIC8vIEhhbmRsZSBzdWJwYXJ0cyAoZmlsZXMgaW4gcy8gZGlyZWN0b3J5KVxyXG4gICAgICAgIGlmIChoYXNTdWJkaXIpIHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBgL2xkcmF3L3BhcnRzL3MvJHtmaWxlbmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgcHJpbWl0aXZlICh1c3VhbGx5IHN0YXJ0IHdpdGggbnVtYmVycyBvciBzcGVjaWZpYyBwYXR0ZXJucylcclxuICAgICAgICBlbHNlIGlmIChmaWxlbmFtZS5tYXRjaCgvXlxcZC8pIHx8IGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ3N0dWQnKSB8fCBmaWxlbmFtZS5zdGFydHNXaXRoKCdlZGdlJykpIHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBgL2xkcmF3L3AvJHtmaWxlbmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWZhdWx0IHRvIHBhcnRzIGRpcmVjdG9yeSBmb3Igb3RoZXIgLmRhdCBmaWxlc1xyXG4gICAgICAgIGVsc2UgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKCcuZGF0JykpIHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBgL2xkcmF3L3BhcnRzLyR7ZmlsZW5hbWV9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yIExEUiBmaWxlcywgdXNlIG91dHB1dCBkaXJlY3RvcnlcclxuICAgICAgICBlbHNlIGlmIChmaWxlbmFtZS5lbmRzV2l0aCgnLmxkcicpIHx8IGZpbGVuYW1lLmVuZHNXaXRoKCcubXBkJykpIHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBgL291dHB1dC8ke2ZpbGVuYW1lfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb25zdHJ1Y3RlZCBVUkw6Jywgbm9ybWFsaXplZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbG9hZGluZ01hbmFnZXJSZWYuY3VycmVudCA9IG1hbmFnZXI7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgbWFuYWdlci5zZXRVUkxNb2RpZmllcih1bmRlZmluZWQpO1xyXG4gICAgICBsb2FkaW5nTWFuYWdlclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCB8fCBpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKDB4ZWVlZWVlKTtcclxuICAgIHNjZW5lUmVmLmN1cnJlbnQgPSBzY2VuZTtcclxuXHJcbiAgICAvLyBDYW1lcmEgd2l0aCBzZXR0aW5ncyBvcHRpbWl6ZWQgZm9yIGxhcmdlIExFR08gbW9kZWxzXHJcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDUwMDAwKTtcclxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMzAwLCA0MDAsIDcwMCk7XHJcbiAgICBjYW1lcmFSZWYuY3VycmVudCA9IGNhbWVyYTtcclxuXHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pO1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgcmVuZGVyZXJSZWYuY3VycmVudCA9IHJlbmRlcmVyO1xyXG5cclxuICAgIGNvbnN0IGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCByZW5kZXJlci5kb21FbGVtZW50KTtcclxuICAgIGNvbnRyb2xzLmVuYWJsZURhbXBpbmcgPSB0cnVlO1xyXG4gICAgY29udHJvbHMuZGFtcGluZ0ZhY3RvciA9IDAuMDU7XHJcbiAgICBjb250cm9scy5lbmFibGVQYW4gPSB0cnVlO1xyXG4gICAgY29udHJvbHMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcclxuICAgIGNvbnRyb2xzLmVuYWJsZVpvb20gPSB0cnVlO1xyXG4gICAgY29udHJvbHMuc2NyZWVuU3BhY2VQYW5uaW5nID0gZmFsc2U7XHJcbiAgICBjb250cm9scy5taW5EaXN0YW5jZSA9IDEwO1xyXG4gICAgY29udHJvbHMubWF4RGlzdGFuY2UgPSAyMDAwO1xyXG4gICAgY29udHJvbHMudGFyZ2V0LnNldCgwLCAwLCAwKTtcclxuICAgIGNvbnRyb2xzUmVmLmN1cnJlbnQgPSBjb250cm9scztcclxuXHJcbiAgICAvLyBFbmhhbmNlZCBsaWdodGluZyBmb3IgYmV0dGVyIHZpc2liaWxpdHlcclxuICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ZmZmZmZmLCAwLjkpKTsgLy8gQnJpZ2h0ZXIgYW1iaWVudCBsaWdodFxyXG5cclxuICAgIC8vIE1haW4gZGlyZWN0aW9uYWwgbGlnaHRcclxuICAgIGNvbnN0IGRpckxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDEuMCk7XHJcbiAgICBkaXJMaWdodC5wb3NpdGlvbi5zZXQoNTAwLCAxMDAwLCA1MDApO1xyXG4gICAgZGlyTGlnaHQuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG4gICAgc2NlbmUuYWRkKGRpckxpZ2h0KTtcclxuXHJcbiAgICAvLyBBZGRpdGlvbmFsIGZpbGwgbGlnaHRzIGZyb20gZGlmZmVyZW50IGFuZ2xlc1xyXG4gICAgY29uc3QgZmlsbExpZ2h0MSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpO1xyXG4gICAgZmlsbExpZ2h0MS5wb3NpdGlvbi5zZXQoLTUwMCwgNTAwLCAtNTAwKTtcclxuICAgIHNjZW5lLmFkZChmaWxsTGlnaHQxKTtcclxuXHJcbiAgICBjb25zdCBmaWxsTGlnaHQyID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuNSk7XHJcbiAgICBmaWxsTGlnaHQyLnBvc2l0aW9uLnNldCg1MDAsIDUwMCwgLTUwMCk7XHJcbiAgICBzY2VuZS5hZGQoZmlsbExpZ2h0Mik7XHJcblxyXG4gICAgLy8gQWRkIGEgaGVtaXNwaGVyZSBsaWdodCBmb3IgbW9yZSBuYXR1cmFsIGxpZ2h0aW5nXHJcbiAgICBjb25zdCBoZW1pTGlnaHQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4ZmZmZmZmLCAweGNjY2NjYywgMC40KTtcclxuICAgIGhlbWlMaWdodC5wb3NpdGlvbi5zZXQoMCwgNTAwLCAwKTtcclxuICAgIHNjZW5lLmFkZChoZW1pTGlnaHQpO1xyXG5cclxuICAgIC8vIEdyaWQgaGVscGVyIHJlbW92ZWRcclxuICAgIC8vIGNvbnN0IGdyaWRIZWxwZXIgPSBuZXcgVEhSRUUuR3JpZEhlbHBlcigxMDAwLCAyMCk7XHJcbiAgICAvLyBzY2VuZS5hZGQoZ3JpZEhlbHBlcik7XHJcblxyXG4gICAgLy8gQWRkIGF4ZXMgaGVscGVyXHJcbiAgICBjb25zdCBheGVzSGVscGVyID0gbmV3IFRIUkVFLkF4ZXNIZWxwZXIoNTAwKTtcclxuICAgIHNjZW5lLmFkZChheGVzSGVscGVyKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50IHx8ICFyZW5kZXJlclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHcgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgY29uc3QgaCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgcmVuZGVyZXJSZWYuY3VycmVudC5zZXRTaXplKHcsIGgpO1xyXG4gICAgICBjYW1lcmFSZWYuY3VycmVudC5hc3BlY3QgPSB3IC8gaDtcclxuICAgICAgY2FtZXJhUmVmLmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICAvLyBBbmltYXRpb24gbG9vcCBpcyBub3cgaGFuZGxlZCBpbiB0aGUgY3ViZSBlZmZlY3RcclxuICAgIGNvbnNvbGUubG9nKCdTY2VuZSBpbml0aWFsaXplZCcpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICAvLyBLZWVwIHJlbmRlcmVyIGludGFjdCBidXQgY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgLy8gaWYgKHJlbmRlcmVyUmVmLmN1cnJlbnQgJiYgY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgLy8gICBjb250YWluZXJSZWYuY3VycmVudC5yZW1vdmVDaGlsZChyZW5kZXJlclJlZi5jdXJyZW50LmRvbUVsZW1lbnQpO1xyXG4gICAgICAvLyAgIHJlbmRlcmVyUmVmLmN1cnJlbnQuZGlzcG9zZSgpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIEFuaW1hdGlvbiBsb29wIC0gdXNpbmcgdXNlUmVmIHRvIGVuc3VyZSBzaW5nbGUgaW5zdGFuY2VcclxuICBjb25zdCBhbmltYXRpb25JZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBpc0FuaW1hdGluZ1JlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXNjZW5lUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50IHx8ICFjb250cm9sc1JlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBhbmltYXRpb24gbG9vcHNcclxuICAgIGlmIChpc0FuaW1hdGluZ1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBbmltYXRpb24gYWxyZWFkeSBydW5uaW5nLCBza2lwcGluZy4uLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tbWVudGVkIG91dCBjYW5jZWxsYXRpb25cclxuICAgIC8vIGlmIChhbmltYXRpb25JZFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAvLyAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkUmVmLmN1cnJlbnQpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGlzQW5pbWF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghaXNBbmltYXRpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgYWxsIHJlZnMgYmVmb3JlIHNjaGVkdWxpbmcgbmV4dCBmcmFtZVxyXG4gICAgICBpZiAoIWNvbnRyb2xzUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIXNjZW5lUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdBbmltYXRpb24gbG9vcCBzdG9wcGVkOiBtaXNzaW5nIHJlZnMnKTtcclxuICAgICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbmltYXRpb25JZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBPbmx5IHZhbGlkYXRlIHNjZW5lIGlmIHdlJ3ZlIGhhZCByZWNlbnQgZXJyb3JzXHJcbiAgICAgICAgaWYgKGVycm9yQ291bnRSZWYuY3VycmVudCA+IDAgJiYgZXJyb3JDb3VudFJlZi5jdXJyZW50IDwgNSkge1xyXG4gICAgICAgICAgbGV0IGhhc051bGxDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgbGV0IG51bGxDaGVja0NvdW50ID0gMDtcclxuICAgICAgICAgIHNjZW5lUmVmLmN1cnJlbnQudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgbnVsbENoZWNrQ291bnQrKztcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9iamVjdCBpdHNlbGYgaGFzIHJlcXVpcmVkIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgaWYgKCFjaGlsZC5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignT2JqZWN0IG1pc3NpbmcgdmlzaWJsZSBwcm9wZXJ0eTonLCBjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbltpXSA9PT0gbnVsbCB8fCBjaGlsZC5jaGlsZHJlbltpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvdW5kIG51bGwvdW5kZWZpbmVkIGNoaWxkIGluIHNjZW5lIGF0IGluZGV4JywgaSwgJ29mIHBhcmVudDonLCBjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgIGhhc051bGxDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbnVsbCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICBjaGlsZC5jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgIGktLTsgLy8gQWRqdXN0IGluZGV4IGFmdGVyIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChoYXNOdWxsQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDbGVhbmVkIG51bGwgY2hpbGRyZW4gZnJvbSBzY2VuZSBncmFwaCBhZnRlciBjaGVja2luZycsIG51bGxDaGVja0NvdW50LCAnb2JqZWN0cycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIGFuZCByZW5kZXJcclxuICAgICAgICAvLyBWYWxpZGF0ZSBjb250cm9scyBzdGF0ZSBiZWZvcmUgdXBkYXRpbmdcclxuICAgICAgICBpZiAoY29udHJvbHNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgY29udHJvbHMgdGFyZ2V0IGlzIHZhbGlkXHJcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LngpIHx8XHJcbiAgICAgICAgICAgICAgIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LnkpIHx8XHJcbiAgICAgICAgICAgICAgIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LnopKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9scyB0YXJnZXQgYmVjYW1lIGludmFsaWQsIHJlc2V0dGluZyB0byBvcmlnaW4nKTtcclxuICAgICAgICAgICAgY29udHJvbHNSZWYuY3VycmVudC50YXJnZXQuc2V0KDAsIDAsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnRyb2xzUmVmLmN1cnJlbnQudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlclJlZi5jdXJyZW50LnJlbmRlcihzY2VuZVJlZi5jdXJyZW50LCBjYW1lcmFSZWYuY3VycmVudCk7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCByZW5kZXJcclxuICAgICAgICBpZiAoZXJyb3JDb3VudFJlZi5jdXJyZW50ID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlbmRlcmluZyByZWNvdmVyZWQgYWZ0ZXInLCBlcnJvckNvdW50UmVmLmN1cnJlbnQsICdlcnJvcnMnKTtcclxuICAgICAgICAgIGVycm9yQ291bnRSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGVycm9yQ291bnRSZWYuY3VycmVudCA9IChlcnJvckNvdW50UmVmLmN1cnJlbnQgfHwgMCkgKyAxO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3JDb3VudFJlZi5jdXJyZW50ID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IGxvZyBkZXRhaWxlZCBpbmZvIG9uIGZpcnN0IGVycm9yXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGaXJzdCBlcnJvciBpbiBhbmltYXRpb24gbG9vcDonLCBlcnJvcik7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTY2VuZSBjaGlsZHJlbiBjb3VudDonLCBzY2VuZVJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTY2VuZSBzdGF0ZTonLCBzY2VuZVJlZi5jdXJyZW50KTtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBzdGF0ZTonLCBjYW1lcmFSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb250cm9scyBzdGF0ZTonLCBjb250cm9sc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgICAgICAvLyBMb2cgdGhlIG1vZGVsIGdyb3VwIHN0YXRlXHJcbiAgICAgICAgICBpZiAobW9kZWxHcm91cFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZGVsIGdyb3VwIHN0YXRlOicsIG1vZGVsR3JvdXBSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZGVsIHZpc2libGU6JywgbW9kZWxHcm91cFJlZi5jdXJyZW50LnZpc2libGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNb2RlbCBjaGlsZHJlbiBjb3VudDonLCBtb2RlbEdyb3VwUmVmLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uIGFmdGVyIHRvbyBtYW55IGVycm9yc1xyXG4gICAgICAgIGlmIChlcnJvckNvdW50UmVmLmN1cnJlbnQgPiAxMDApIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RvbyBtYW55IHJlbmRlciBlcnJvcnMsIHN0b3BwaW5nIGFuaW1hdGlvbiBsb29wJyk7XHJcbiAgICAgICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgYW5pbWF0ZSgpO1xyXG4gICAgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBsb29wIHN0YXJ0ZWQnKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAvLyBQcm9wZXJseSBjbGVhbiB1cCBhbmltYXRpb24gbG9vcFxyXG4gICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGlmIChhbmltYXRpb25JZFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgYW5pbWF0aW9uSWRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBUZXN0IGN1YmUgY29tbWVudGVkIG91dCAtIExFR08gbW9kZWwgc2hvdWxkIGxvYWQgaW5zdGVhZFxyXG4gIC8qXHJcbiAgY29uc3QgY3ViZVJlZiA9IHVzZVJlZjxUSFJFRS5NZXNoIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXNjZW5lUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAvLyBQcmV2ZW50IGFkZGluZyBjdWJlIG11bHRpcGxlIHRpbWVzXHJcbiAgICBpZiAoY3ViZVJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gQWRkIGEgc2ltcGxlIHJlZCBjdWJlIHRoYXQgd2Uga25vdyB3b3Jrc1xyXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMzAsIDMwLCAzMCk7XHJcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XHJcbiAgICAgIGNvbG9yOiAweGZmMDAwMCxcclxuICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgIGN1YmUucG9zaXRpb24uc2V0KDAsIDMwMCwgMCk7XHJcblxyXG4gICAgc2NlbmVSZWYuY3VycmVudC5hZGQoY3ViZSk7XHJcblxyXG4gICAgY3ViZVJlZi5jdXJyZW50ID0gY3ViZTtcclxuICAgIGNvbnNvbGUubG9nKCdTaW1wbGUgdGVzdCBjdWJlIGFkZGVkIGF0OicsIGN1YmUucG9zaXRpb24pO1xyXG4gICAgY29uc29sZS5sb2coJ1NjZW5lIG5vdyBoYXMnLCBzY2VuZVJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCwgJ2NoaWxkcmVuJyk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gQ29tbWVudGVkIG91dCBjbGVhbnVwIHRvIGtlZXAgdGhlIGN1YmUgdmlzaWJsZVxyXG4gICAgICAvLyBpZiAoc2NlbmVSZWYuY3VycmVudCAmJiBjdWJlKSB7XHJcbiAgICAgIC8vICAgc2NlbmVSZWYuY3VycmVudC5yZW1vdmUoY3ViZSk7ICAvLyBBbHNvIG5lZWQgdG8gcHJldmVudCByZW1vdmFsIGZyb20gc2NlbmVcclxuICAgICAgLy8gICBnZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgIC8vICAgbWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGN1YmVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuICAqL1xyXG5cclxuICAvLyBDdWJlIGFuaW1hdGlvbiBjb21tZW50ZWQgb3V0IHNpbmNlIGN1YmUgaXMgcmVtb3ZlZFxyXG4gIC8qXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChjdWJlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdWJlUmVmLmN1cnJlbnQucm90YXRpb24ueCArPSAwLjAxO1xyXG4gICAgICAgIGN1YmVSZWYuY3VycmVudC5yb3RhdGlvbi55ICs9IDAuMDE7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbChhbmltYXRlLCAxNik7IC8vIH42MGZwc1xyXG5cclxuICAgIC8vIENvbW1lbnRlZCBvdXQgaW50ZXJ2YWwgY2xlYW51cFxyXG4gICAgLy8gcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaWQpO1xyXG4gICAgcmV0dXJuICgpID0+IHt9O1xyXG4gIH0sIFtdKTtcclxuICAqL1xyXG5cclxuICAvLyBMRUdPIExPQURJTkcgQ09ERVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBOZWVkIGVpdGhlciBtb2RlbFBhdGggb3IgbGRyYXdDb250ZW50XHJcbiAgICBpZiAoKCFtb2RlbFBhdGggJiYgIWxkcmF3Q29udGVudCkgfHwgIXNjZW5lUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gU2tpcCBpZiB3ZSdyZSBhbHJlYWR5IGxvYWRpbmcgdGhpcyBleGFjdCBtb2RlbFxyXG4gICAgaWYgKGN1cnJlbnRNb2RlbFBhdGhSZWYuY3VycmVudCA9PT0gbW9kZWxQYXRoICYmIGlzTG9hZGluZ1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTYW1lIG1vZGVsIGFscmVhZHkgbG9hZGluZywgc2tpcHBpbmcuLi4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNraXAgaWYgdGhpcyBtb2RlbCBpcyBhbHJlYWR5IGxvYWRlZFxyXG4gICAgaWYgKGN1cnJlbnRNb2RlbFBhdGhSZWYuY3VycmVudCA9PT0gbW9kZWxQYXRoICYmIG1vZGVsR3JvdXBSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTW9kZWwgYWxyZWFkeSBsb2FkZWQsIHNraXBwaW5nLi4uJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmV2ZW50IGNvbmN1cnJlbnQgbG9hZHNcclxuICAgIGlmIChpc0xvYWRpbmdSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQW5vdGhlciBtb2RlbCBpcyBsb2FkaW5nLCBza2lwcGluZy4uLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgcHJldmlvdXMgbW9kZWwgc2FmZWx5XHJcbiAgICBpZiAobW9kZWxHcm91cFJlZi5jdXJyZW50ICYmIHNjZW5lUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1JlbW92aW5nIHByZXZpb3VzIG1vZGVsIGZyb20gc2NlbmUnKTtcclxuICAgICAgLy8gTWFyayBhcyBpbnZpc2libGUgZmlyc3QgdG8gcHJldmVudCByZW5kZXIgaXNzdWVzXHJcbiAgICAgIG1vZGVsR3JvdXBSZWYuY3VycmVudC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZnJvbSBzY2VuZSBvbiBuZXh0IHRpY2tcclxuICAgICAgY29uc3QgbW9kZWxUb1JlbW92ZSA9IG1vZGVsR3JvdXBSZWYuY3VycmVudDtcclxuICAgICAgbW9kZWxHcm91cFJlZi5jdXJyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzY2VuZVJlZi5jdXJyZW50ICYmIG1vZGVsVG9SZW1vdmUpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdBY3R1YWxseSByZW1vdmluZyBtb2RlbCBhbmQgZGlzcG9zaW5nIHJlc291cmNlcycpO1xyXG4gICAgICAgICAgc2NlbmVSZWYuY3VycmVudC5yZW1vdmUobW9kZWxUb1JlbW92ZSk7XHJcbiAgICAgICAgICAvLyBEaXNwb3NlIG9mIGdlb21ldHJpZXMgYW5kIG1hdGVyaWFscyBpZiBuZWVkZWRcclxuICAgICAgICAgIG1vZGVsVG9SZW1vdmUudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmdlb21ldHJ5KSBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkLm1hdGVyaWFsKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuZm9yRWFjaCgobWF0OiBhbnkpID0+IG1hdC5kaXNwb3NlKCkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCByZW1vdmFsIGNvbXBsZXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGxvYWRzIG9mIHRoZSBzYW1lIG1vZGVsXHJcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICBpc0xvYWRpbmdSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICBjdXJyZW50TW9kZWxQYXRoUmVmLmN1cnJlbnQgPSBtb2RlbFBhdGggfHwgJ2dlbmVyYXRlZCc7XHJcblxyXG4gICAgY29uc3QgbG9hZGVyID0gbmV3IExEcmF3TG9hZGVyKGxvYWRpbmdNYW5hZ2VyUmVmLmN1cnJlbnQgPz8gdW5kZWZpbmVkKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIHBhcnRzIGxpYnJhcnkgcGF0aCB0byB0aGUgbGRyYXcgZGlyZWN0b3J5XHJcbiAgICBsb2FkZXIuc2V0UGFydHNMaWJyYXJ5UGF0aCgnL2xkcmF3LycpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgZmlsZSBtYXAgZm9yIGJldHRlciBwYXJ0IHJlc29sdXRpb25cclxuICAgIGxvYWRlci5zZXRGaWxlTWFwKHt9KTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGNvbmRpdGlvbmFsIGxpbmUgbWF0ZXJpYWwgY2xhc3MgKG5vdCBhbiBpbnN0YW5jZSlcclxuICAgIGxvYWRlci5zZXRDb25kaXRpb25hbExpbmVNYXRlcmlhbChMRHJhd0NvbmRpdGlvbmFsTGluZU1hdGVyaWFsKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhsZHJhd0NvbnRlbnQgPyAnTG9hZGluZyBMRHJhdyBmcm9tIGNvbnRlbnQnIDogYExvYWRpbmcgTERSIGZpbGU6ICR7bW9kZWxQYXRofWApO1xyXG5cclxuICAgIC8vIFRyeSB0byBwcmVsb2FkIG1hdGVyaWFscyBmaXJzdCwgYnV0IGRvbid0IGZhaWwgaWYgaXQgZG9lc24ndCB3b3JrXHJcbiAgICBjb25zdCBtYXRlcmlhbHNQcm9taXNlID0gbG9hZGVyLnByZWxvYWRNYXRlcmlhbHMoJy9sZHJhdy9MRENvbmZpZy5sZHInKVxyXG4gICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01hdGVyaWFscyBwcmVsb2FkZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgcHJlbG9hZCBtYXRlcmlhbHMsIHVzaW5nIGRlZmF1bHRzOicsIGVyci5tZXNzYWdlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gTG9hZCB0aGUgbW9kZWwgKHdhaXQgZm9yIG1hdGVyaWFscyBpZiBwb3NzaWJsZSwgYnV0IGRvbid0IGJsb2NrKVxyXG4gICAgUHJvbWlzZS5hbGwoW21hdGVyaWFsc1Byb21pc2VdKVxyXG4gICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGRpcmVjdCBjb250ZW50LCBwYXJzZSBpdDsgb3RoZXJ3aXNlIGxvYWQgZnJvbSBmaWxlXHJcbiAgICAgICAgaWYgKGxkcmF3Q29udGVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIGxvYWRlci5wYXJzZShsZHJhd0NvbnRlbnQsICcvJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlbFBhdGgpIHtcclxuICAgICAgICAgIHJldHVybiBsb2FkZXIubG9hZEFzeW5jKG1vZGVsUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KVxyXG4gICAgICAudGhlbigoZ3JvdXApID0+IHtcclxuICAgICAgICBpZiAoIWdyb3VwIHx8IGNhbmNlbGxlZCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBsb2FkZWQgc3VjY2Vzc2Z1bGx5OicsIGdyb3VwKTtcclxuICAgICAgICBpc0xvYWRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBGaXggbnVsbCBtYXRlcmlhbHMgYW5kIGNoaWxkcmVuIGlzc3Vlc1xyXG4gICAgICAgIGdyb3VwLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG51bGwgY2hpbGRyZW5cclxuICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgY2hpbGQuY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbi5maWx0ZXIoKGM6IGFueSkgPT4gYyAhPT0gbnVsbCAmJiBjICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoICE9PSBvcmlnaW5hbExlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVtb3ZlZCBudWxsIGNoaWxkcmVuIGZyb206JywgY2hpbGQubmFtZSB8fCBjaGlsZC51dWlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZpeCBudWxsIG1hdGVyaWFsc1xyXG4gICAgICAgICAgaWYgKChjaGlsZCBhcyBhbnkpLmlzTWVzaCkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNoID0gY2hpbGQgYXMgVEhSRUUuTWVzaDtcclxuICAgICAgICAgICAgaWYgKCFtZXNoLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZGVmYXVsdCBtYXRlcmlhbCBpZiBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgbWVzaC5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogMHg4MDgwODAsXHJcbiAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGVkIGRlZmF1bHQgbWF0ZXJpYWwgdG8gbWVzaDonLCBtZXNoLm5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVzaC5tYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgICAvLyBDaGVjayBhcnJheSBvZiBtYXRlcmlhbHNcclxuICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbC5tYXAoKG1hdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcGxhY2luZyBudWxsIG1hdGVyaWFsIGluIGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAweDgwODA4MCxcclxuICAgICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbiBtb2RlbCBhdCBvcmlnaW4gYW5kIHJvdGF0ZSAxODAgZGVncmVlc1xyXG4gICAgICAgIGdyb3VwLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcclxuICAgICAgICAvLyBncm91cC5yb3RhdGlvbi54ID0gTWF0aC5QSTsgLy8gUm90YXRlIDE4MCBkZWdyZWVzIGFyb3VuZCBYIGF4aXNcclxuICAgICAgICBtb2RlbEdyb3VwUmVmLmN1cnJlbnQgPSBncm91cDtcclxuXHJcbiAgICAgICAgaWYgKHNjZW5lUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHNjZW5lUmVmLmN1cnJlbnQuYWRkKGdyb3VwKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBhZGRlZCB0byBzY2VuZScpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0dyb3VwIGNoaWxkcmVuOicsIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnR3JvdXAgdmlzaWJsZTonLCBncm91cC52aXNpYmxlKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdHcm91cCBpbiBzY2VuZTonLCBzY2VuZVJlZi5jdXJyZW50LmNoaWxkcmVuLmluY2x1ZGVzKGdyb3VwKSk7XHJcblxyXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBncm91cCBpcyB2aXNpYmxlXHJcbiAgICAgICAgICBncm91cC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgIGdyb3VwLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHZpc2libGUgbWVzaGVzIGFuZCBjaGVjayBtYXRlcmlhbHNcclxuICAgICAgICAgIGxldCBtZXNoQ291bnQgPSAwO1xyXG4gICAgICAgICAgbGV0IHZpc2libGVDb3VudCA9IDA7XHJcbiAgICAgICAgICBncm91cC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKChjaGlsZCBhcyBhbnkpLmlzTWVzaCkge1xyXG4gICAgICAgICAgICAgIG1lc2hDb3VudCsrO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBjaGlsZCBhcyBUSFJFRS5NZXNoO1xyXG4gICAgICAgICAgICAgIGlmIChtZXNoLnZpc2libGUpIHZpc2libGVDb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIW1lc2guZ2VvbWV0cnkuYm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBMb2cgbWVzaCBkZXRhaWxzXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01lc2ggZGV0YWlsczonLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBtZXNoLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBtZXNoLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogbWVzaC5tYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5VmVydGljZXM6IG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbj8uY291bnQgfHwgMCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtZXNoLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IG1lc2guc2NhbGVcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG1lc2ggaGFzIGEgbWF0ZXJpYWxcclxuICAgICAgICAgICAgICBpZiAoIW1lc2gubWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWVzaCBoYXMgbm8gbWF0ZXJpYWwsIGFkZGluZyBkZWZhdWx0Jyk7XHJcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcclxuICAgICAgICAgICAgICAgICAgY29sb3I6IDB4ZmYwMDAwLFxyXG4gICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7bWVzaENvdW50fSBtZXNoZXMsICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlYCk7XHJcblxyXG4gICAgICAgICAgLy8gVGVzdCBjdWJlIHJlbW92ZWQgLSByZW5kZXJpbmcgdmVyaWZpZWQgdG8gYmUgd29ya2luZ1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUwLCA1MCwgNTApO1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHsgY29sb3I6IDB4MDBmZjAwIH0pO1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdEN1YmUgPSBuZXcgVEhSRUUuTWVzaCh0ZXN0R2VvbWV0cnksIHRlc3RNYXRlcmlhbCk7XHJcbiAgICAgICAgICAvLyB0ZXN0Q3ViZS5wb3NpdGlvbi5zZXQoMTAwLCAyNSwgMCk7XHJcbiAgICAgICAgICAvLyBzY2VuZVJlZi5jdXJyZW50LmFkZCh0ZXN0Q3ViZSk7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVGVzdCBjdWJlIGFkZGVkIGF0OicsIHRlc3RDdWJlLnBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvcmNlIHVwZGF0ZSBtYXRyaWNlcyBiZWZvcmUgY2FsY3VsYXRpbmcgYm91bmRpbmcgYm94XHJcbiAgICAgICAgZ3JvdXAudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBib3VuZGluZyBib3ggYW5kIGNlbnRlciBjYW1lcmFcclxuICAgICAgICBjb25zdCBib3ggPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21PYmplY3QoZ3JvdXApO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJveC5nZXRDZW50ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJveC5nZXRTaXplKG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xyXG5cclxuICAgICAgICAvLyBMb2cgbW9kZWwgaW5mb3JtYXRpb25cclxuICAgICAgICBpZiAoIWJveC5pc0VtcHR5KCkgJiYgc2l6ZS54ID4gMCAmJiBzaXplLnkgPiAwICYmIHNpemUueiA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBjZW50ZXI6JywgY2VudGVyLngsIGNlbnRlci55LCBjZW50ZXIueik7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTW9kZWwgc2l6ZTonLCBzaXplLngsIHNpemUueSwgc2l6ZS56KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdNb2RlbCBoYXMgZW1wdHkvaW52YWxpZCBib3VuZGluZyBib3gnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAvLyBKdXN0IHVwZGF0ZSBjb250cm9scyB0byBsb29rIGF0IG9yaWdpblxyXG4gICAgICAgICAgY29udHJvbHNSZWYuY3VycmVudC50YXJnZXQuc2V0KDAsIDAsIDApO1xyXG4gICAgICAgICAgY29udHJvbHNSZWYuY3VycmVudC51cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGhhbmRsZSByZW5kZXJpbmdcclxuICAgICAgICBjb25zb2xlLmxvZygnU2NlbmUgY2hpbGRyZW46Jywgc2NlbmVSZWYuY3VycmVudD8uY2hpbGRyZW4ubGVuZ3RoIHx8IDApO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbW9kZWw6JywgZXJyb3IpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZGVsIHBhdGg6JywgbW9kZWxQYXRoKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdGFjayB0cmFjZTonLCBlcnJvci5zdGFjayk7XHJcbiAgICAgICAgaXNMb2FkaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvbiAtIG9ubHkgcmVtb3ZlIG1vZGVsIGlmIHBhdGggY2hhbmdlcyBvciBjb21wb25lbnQgdW5tb3VudHNcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBtb2RlbCBoZXJlIC0gaXQgd2lsbCBiZSBjbGVhcmVkIHdoZW4gYSBuZXcgbW9kZWwgbG9hZHNcclxuICAgICAgLy8gb3Igd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXHJcbiAgICB9O1xyXG4gIH0sIFttb2RlbFBhdGhdKTtcclxuXHJcbiAgLy8gQ2xlYW4gdXAgbW9kZWwgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKG1vZGVsR3JvdXBSZWYuY3VycmVudCAmJiBzY2VuZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gTWFyayBhcyBpbnZpc2libGUgZmlyc3RcclxuICAgICAgICBtb2RlbEdyb3VwUmVmLmN1cnJlbnQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFRoZW4gcmVtb3ZlXHJcbiAgICAgICAgc2NlbmVSZWYuY3VycmVudC5yZW1vdmUobW9kZWxHcm91cFJlZi5jdXJyZW50KTtcclxuICAgICAgICBtb2RlbEdyb3VwUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGlzTG9hZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGN1cnJlbnRNb2RlbFBhdGhSZWYuY3VycmVudCA9ICcnO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2XHJcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnNjAwcHgnLFxyXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJyxcclxuICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxyXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICB9fVxyXG4gICAgLz5cclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgTERSVmlld2VyID0gbWVtbyhMRFJWaWV3ZXJDb21wb25lbnQpO1xyXG5leHBvcnQgZGVmYXVsdCBMRFJWaWV3ZXI7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIm1lbW8iLCJUSFJFRSIsIk9yYml0Q29udHJvbHMiLCJMRHJhd0xvYWRlciIsIkxEcmF3Q29uZGl0aW9uYWxMaW5lTWF0ZXJpYWwiLCJMRFJWaWV3ZXJDb21wb25lbnQiLCJtb2RlbFBhdGgiLCJsZHJhd0NvbnRlbnQiLCJjb250YWluZXJSZWYiLCJzY2VuZVJlZiIsInJlbmRlcmVyUmVmIiwiY2FtZXJhUmVmIiwiY29udHJvbHNSZWYiLCJtb2RlbEdyb3VwUmVmIiwibG9hZGluZ01hbmFnZXJSZWYiLCJpc0xvYWRpbmdSZWYiLCJjdXJyZW50TW9kZWxQYXRoUmVmIiwiaXNJbml0aWFsaXplZFJlZiIsImVycm9yQ291bnRSZWYiLCJjdXJyZW50IiwibWFuYWdlciIsIkxvYWRpbmdNYW5hZ2VyIiwic2V0VVJMTW9kaWZpZXIiLCJ1cmwiLCJub3JtYWxpemVkIiwicmVwbGFjZSIsImluY2x1ZGVzIiwibWF0Y2giLCJwYXJ0cyIsInNwbGl0IiwibGFzdFR3byIsInNsaWNlIiwidXJsUGFydHMiLCJmaWxlbmFtZSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaGFzU3ViZGlyIiwicGF0aFByZWZpeGVzIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidW5kZWZpbmVkIiwiY29udGFpbmVyIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInNjZW5lIiwiU2NlbmUiLCJiYWNrZ3JvdW5kIiwiQ29sb3IiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInBvc2l0aW9uIiwic2V0IiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0U2l6ZSIsInNldFBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiY29udHJvbHMiLCJlbmFibGVEYW1waW5nIiwiZGFtcGluZ0ZhY3RvciIsImVuYWJsZVBhbiIsImVuYWJsZVJvdGF0ZSIsImVuYWJsZVpvb20iLCJzY3JlZW5TcGFjZVBhbm5pbmciLCJtaW5EaXN0YW5jZSIsIm1heERpc3RhbmNlIiwidGFyZ2V0IiwiYWRkIiwiQW1iaWVudExpZ2h0IiwiZGlyTGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiY2FzdFNoYWRvdyIsImZpbGxMaWdodDEiLCJmaWxsTGlnaHQyIiwiaGVtaUxpZ2h0IiwiSGVtaXNwaGVyZUxpZ2h0IiwiYXhlc0hlbHBlciIsIkF4ZXNIZWxwZXIiLCJoYW5kbGVSZXNpemUiLCJ3IiwiaCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJhZGRFdmVudExpc3RlbmVyIiwiY29uc29sZSIsImxvZyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhbmltYXRpb25JZFJlZiIsImlzQW5pbWF0aW5nUmVmIiwiYW5pbWF0ZSIsIndhcm4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYXNOdWxsQ2hpbGRyZW4iLCJudWxsQ2hlY2tDb3VudCIsInRyYXZlcnNlIiwiY2hpbGQiLCJoYXNPd25Qcm9wZXJ0eSIsImVycm9yIiwiY2hpbGRyZW4iLCJpIiwic3BsaWNlIiwiaXNGaW5pdGUiLCJ4IiwieSIsInoiLCJ1cGRhdGUiLCJyZW5kZXIiLCJ2aXNpYmxlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtb2RlbFRvUmVtb3ZlIiwic2V0VGltZW91dCIsInJlbW92ZSIsImdlb21ldHJ5IiwiZGlzcG9zZSIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNhbmNlbGxlZCIsImxvYWRlciIsInNldFBhcnRzTGlicmFyeVBhdGgiLCJzZXRGaWxlTWFwIiwic2V0Q29uZGl0aW9uYWxMaW5lTWF0ZXJpYWwiLCJtYXRlcmlhbHNQcm9taXNlIiwicHJlbG9hZE1hdGVyaWFscyIsInRoZW4iLCJjYXRjaCIsImVyciIsIm1lc3NhZ2UiLCJQcm9taXNlIiwiYWxsIiwicGFyc2UiLCJsb2FkQXN5bmMiLCJncm91cCIsIm9yaWdpbmFsTGVuZ3RoIiwiZmlsdGVyIiwiYyIsIm5hbWUiLCJ1dWlkIiwiaXNNZXNoIiwibWVzaCIsIk1lc2hQaG9uZ01hdGVyaWFsIiwiY29sb3IiLCJzaWRlIiwiRG91YmxlU2lkZSIsIm1hcCIsIm1lc2hDb3VudCIsInZpc2libGVDb3VudCIsImJvdW5kaW5nQm94IiwiY29tcHV0ZUJvdW5kaW5nQm94IiwiZ2VvbWV0cnlWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJjb3VudCIsInNjYWxlIiwidXBkYXRlTWF0cml4V29ybGQiLCJib3giLCJCb3gzIiwic2V0RnJvbU9iamVjdCIsImNlbnRlciIsImdldENlbnRlciIsIlZlY3RvcjMiLCJzaXplIiwiZ2V0U2l6ZSIsImlzRW1wdHkiLCJzdGFjayIsImRpdiIsInJlZiIsInN0eWxlIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwib3ZlcmZsb3ciLCJMRFJWaWV3ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/LDRViewer.tsx\n"));

/***/ })

});